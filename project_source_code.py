# -*- coding: utf-8 -*-
"""Project_Source Code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZvI67gG-yjk3-7QPT-7Z0LUu06R49Mw-
"""

import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import classification_report, confusion_matrix, roc_curve, auc
import seaborn as sns
import cv2
from google.colab import drive
drive.mount('/content/drive')
from google.colab import files
from PIL import Image

# Define paths to your dataset
train_dir = '/content/drive/MyDrive/Capstone project'
val_dir = '/content/drive/MyDrive/Capstone project'

# Image data generator for preprocessing
train_datagen = ImageDataGenerator(rescale=1./255,
                                    rotation_range=20,
                                    width_shift_range=0.2,
                                    height_shift_range=0.2,
                                    shear_range=0.2,
                                    zoom_range=0.2,
                                    horizontal_flip=True,
                                    fill_mode='nearest')

val_datagen = ImageDataGenerator(rescale=1./255)

# Load images
train_generator = train_datagen.flow_from_directory(train_dir,
                                                    target_size=(224, 224),
                                                    batch_size=32,
                                                    class_mode='binary')

val_generator = val_datagen.flow_from_directory(val_dir,
                                                target_size=(224, 224),
                                                batch_size=32,
                                                class_mode='binary')

# Load the ResNet50 model
base_model = tf.keras.applications.ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Freeze the base model
base_model.trainable = False

# Create the model
model = models.Sequential([
    base_model,
    layers.GlobalAveragePooling2D(),
    layers.Dense(1, activation='sigmoid')
])

# Compile the model
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
history = model.fit(train_generator,
                    validation_data=val_generator,
                    epochs=10)

# Evaluate the model
val_loss, val_accuracy = model.evaluate(val_generator)
print(f'Validation Accuracy: {val_accuracy:.2f}')

# âœ… Save the model right after training
model.save("brain_tumor_model.h5")

# Plotting accuracy and loss
plt.figure(figsize=(12, 4))

# Accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend()

# Loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.title('Model Loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.legend()

plt.show()

# Predictions
val_generator.reset()
predictions = model.predict(val_generator)
predicted_classes = np.where(predictions > 0.5, 1, 0)

# Classification report
print(classification_report(val_generator.classes, predicted_classes))

# Confusion matrix
conf_matrix = confusion_matrix(val_generator.classes, predicted_classes)
sns.heatmap(conf_matrix, annot=True, fmt='d', cmap='Blues')
plt.xlabel('Predicted')
plt.ylabel('True')
plt.title('Confusion Matrix')
plt.show()

# ROC and AUC
fpr, tpr, thresholds = roc_curve(val_generator.classes, predictions)
roc_auc = auc(fpr, tpr)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC curve (area = %0.2f)' % roc_auc)
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver Operating Characteristic')
plt.legend(loc="lower right")
plt.show()


    # Function to predict on a new image
def predict_image(image_path):
    # Load and preprocess the image
    img = Image.open(image_path)
    img = img.resize((224, 224))  # Resize to match model input
    img_array = np.array(img) / 255.0  # Normalize the image
    img_array = np.expand_dims(img_array, axis=0)  # Add batch dimension

    # Make prediction
    prediction = model.predict(img_array)
    predicted_class = 'tumor' if prediction[0][0] > 0.5 else 'no tumor'

    # Display the image
    plt.imshow(img)
    plt.axis('off')
    plt.title(f'Prediction: {predicted_class}')
    plt.show()

    return predicted_class

# Ask user for input
uploaded = files.upload()  # This will prompt the user to upload an image

# Get the uploaded file name
for filename in uploaded.keys():
    print(f'User  uploaded file "{filename}"')
    result = predict_image(filename)
    print(f'The uploaded image is predicted to be: {result}')

    model.save("brain_tumor_model.h5")

from google.colab import drive
drive.mount('/content/drive')

pip install streamlit pillow tensorflow

import streamlit as st
from PIL import Image
import numpy as np
import tensorflow as tf

# Load the trained model
model = tf.keras.models.load_model("brain_tumor_model.h5")

# Function to make prediction
def predict_image(img):
    img = img.resize((224, 224))
    img_array = np.array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)
    prediction = model.predict(img_array)
    return 'Tumor' if prediction[0][0] > 0.5 else 'No Tumor'

# Streamlit UI
st.title("Brain Tumor Detection")
st.write("Upload an MRI image to detect if it has a tumor.")

uploaded_file = st.file_uploader("Choose an image...", type=["jpg", "png", "jpeg"])

if uploaded_file is not None:
    image = Image.open(uploaded_file)
    st.image(image, caption='Uploaded Image', use_column_width=True)
    result = predict_image(image)
    st.markdown(f"### Prediction: {result}")